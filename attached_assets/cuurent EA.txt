
//+------------------------------------------------------------------+
//| Return symbol's digits                                           |
//+------------------------------------------------------------------+
int GetSymbolDigits(const string sym)
{
    Print("Checking symbol: ", sym);  // Debug info
    
    // First ensure the symbol is in Market Watch
    if(!SymbolSelect(sym, true)) {
        Print("ERROR: Symbol not found in Market Watch: ", sym);
        return _Digits; // Use chart digits as fallback
    }
    
    int digits = (int)SymbolInfoInteger(sym, SYMBOL_DIGITS);
    if(digits < 0) {
        int error = GetLastError();
        Print("ERROR getting digits for symbol: ", sym, " Error: ", error, " - ", ErrorDescription(error));
        digits = _Digits;
    }
    Print("Symbol ", sym, " has ", digits, " digits");
    return digits;
}
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                             MT5_GENESIS_EA.mq5 |
//|                                       GENESIS Trading Platform |
//|                                                                |
//+------------------------------------------------------------------+
#property copyright "GENESIS Trading Platform"
#property link      ""
#property version   "1.00"
#property strict

// Include required libraries
#include <Trade/Trade.mqh>           // For trading operations
#include <Arrays/ArrayString.mqh>    // For string array operations
#include <JAson.mqh>                 // For JSON operations, needs to be installed
#include <StdLib.mqh>
#define MAX_TRADES_PER_UPDATE   20   // keep each WebRequest under ~10 KB



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#define DBG  if(DebugLogs) Print               // For ErrorDescription()
//--- Updated API constants 2025-05-03
#define API_ENDPOINT "https://4c1f2076-899e-4ced-962a-2903ca4a9bac-00-29hcpk84r1chm.picard.replit.dev"
#define MT5_API_PATH "/mt5"
#define GET_SIGNALS_PATH "/get_signals"
#define HEARTBEAT_PATH "/heartbeat"
#define ACCOUNT_STATUS_PATH "/account_status"
#define TRADE_UPDATE_PATH "/update_trades"
#define TRADE_REPORT_PATH "/trade_report"
const string SIGNALS_URL      = API_ENDPOINT + MT5_API_PATH + GET_SIGNALS_PATH;
const string HEARTBEAT_URL    = API_ENDPOINT + MT5_API_PATH + HEARTBEAT_PATH;
const string ACCOUNT_STATUS_URL = API_ENDPOINT + MT5_API_PATH + ACCOUNT_STATUS_PATH;
const string TRADE_UPDATE_URL   = API_ENDPOINT + MT5_API_PATH + TRADE_UPDATE_PATH;
const string TRADE_REPORT_URL   = API_ENDPOINT + MT5_API_PATH + TRADE_REPORT_PATH;

bool IsMarketOpenForSymbol(string symbol, bool force_execution=false);
// Constants
#define API_TIMEOUT  5000            // Timeout for API requests in milliseconds
#define SIGNAL_CHECK_INTERVAL 10     // How often to check for new signals (seconds)
#define HEARTBEAT_INTERVAL 60        // How often to send heartbeat (seconds)

// Input parameters
input string   API_Key      = "";    // API Key for authentication
input string   AccountName  = "";    // Account name/identifier
input bool     AutoTrade    = true;  // Automatically execute trades
input bool     SendReports  = true;  // Send trade reports back to GENESIS
input double   LotMultiplier = 1.0;  // Multiplier for lot size from signals
input int      SlippagePoints = 10;  // Maximum allowed slippage in points
input bool     SendHeartbeat = true;
input bool     ShowAlerts   = true;  // Pop-up alerts
input bool     DebugLogs   = false; // verbose housekeeping prints // Send heartbeat to GENESIS platform
string gAccountId = "";   // runtime account identifier

// Global variables
CTrade         Trade;                // Trading object
CJAVal         JsonToSend;           // JSON object for sending data
CJAVal         JsonReceived;         // JSON object for receiving data
int            LastSignalId = 0;     // Last processed signal ID
datetime       LastSignalCheck = 0;  // Last time signals were checked
datetime       LastHeartbeat = 0;    // Last time heartbeat was sent
string         ActiveSymbols[];      // List of symbols in Market Watch
int            RetryCount = 0;       // Counter for API retry attempts
bool           InitialSetupDone = false; // Flag for initial setup
int            TerminalNumber = 0;   // Unique identifier for this terminal

// Global variables for signal arrows
color    EntryBuyColor  = clrLime;     // Entry arrow for executed buys
color    EntrySellColor = clrRed;      // Entry arrow for executed sells
string   LinePrefix = "GENESIS_Line_"; // Prefix for entry/SL/TP lines

color    AnticipatedLongColor = clrDodgerBlue;    // Color for anticipated long signals
color    AnticipatedShortColor = clrCrimson;      // Color for anticipated short signals
int      ArrowSize = 3;                           // Size of the signal arrows
int      ArrowOffset = 5;                         // Offset from price in points
string   ArrowPrefix = "GENESIS_Arrow_";         // Prefix for arrow objects

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    // Print startup message
    DBG("GENESIS EA starting up...");
    
    // Generate a unique terminal identifier
    TerminalNumber = MathRand();
    gAccountId = (StringLen(AccountName) > 0) ? AccountName : IntegerToString((int)AccountInfoInteger(ACCOUNT_LOGIN));
    Print("DEBUG gAccountId = '", gAccountId, "'");
    
    // Set up trading parameters
    Trade.SetDeviationInPoints(SlippagePoints);
    Trade.SetExpertMagicNumber(123456); // Set a unique magic number
    
    // Get all symbols in Market Watch
    GetActiveSymbols();
    
    // Initialize JSON object
    JsonToSend.Clear();
    
    // Send initial heartbeat
    if(SendHeartbeat) {
        SendHeartbeatToGenesis();
    }
    
    // Create timer for checking signals and heartbeat
    EventSetTimer(1);  // 1 second timer
    
    // Mark initial setup as complete
    InitialSetupDone = true;
    
    // Clear any existing objects on the chart
    DeleteAllSignalArrows();
    return(INIT_SUCCEEDED);
    
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Delete timer
    EventKillTimer();
    
    // Print shutdown message
    DBG("GENESIS EA shutting down, reason: ", GetDeinitReasonText(reason));
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // Main trading logic happens in OnTimer
}

//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
   // â”€â”€ 1.  Send account status every 15 s â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   static datetime lastAccountUpdate = 0;
   if((TimeCurrent() - lastAccountUpdate) >= 15)
     {
      SendAccountStatus();
      lastAccountUpdate = TimeCurrent();
     }

   // â”€â”€ 2.  Send trade updates every 20 s â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   static datetime lastTradeUpdate = 0;
   if((TimeCurrent() - lastTradeUpdate) >= 20)
     {
      SendTradeUpdates();                 // <-- keep just this ONE call
      lastTradeUpdate = TimeCurrent();
     }

   // â”€â”€ 3.  Heart-beat to server (if enabled) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if(SendHeartbeat && (TimeCurrent() - LastHeartbeat) >= HEARTBEAT_INTERVAL)
     {
      SendHeartbeatToGenesis();
      LastHeartbeat = TimeCurrent();
     }

   // â”€â”€ 4.  Poll for new Genesis signals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if((TimeCurrent() - LastSignalCheck) >= SIGNAL_CHECK_INTERVAL)
     {
      GetNewSignalsFromGenesis();
      LastSignalCheck = TimeCurrent();
     }
  }

//+------------------------------------------------------------------+
//| Sync positions after every trade event                           |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest     &request,
                        const MqlTradeResult      &result)
  {
   // Fire only on meaningful order / deal changes
   if(trans.type==TRADE_TRANSACTION_DEAL_ADD     ||
      trans.type==TRADE_TRANSACTION_DEAL_UPDATE  ||
      trans.type==TRADE_TRANSACTION_ORDER_ADD    ||
      trans.type==TRADE_TRANSACTION_ORDER_UPDATE)
     {
      SendTradeUpdates();      // ðŸš€ push snapshot to the Python server
     }
  }

//+------------------------------------------------------------------+
//| Get all active symbols from Market Watch                         |
//+------------------------------------------------------------------+
void GetActiveSymbols()
{
    int symbolsTotal = SymbolsTotal(true);
    ArrayResize(ActiveSymbols, symbolsTotal);
    
    for(int i = 0; i < symbolsTotal; i++) {
        ActiveSymbols[i] = SymbolName(i, true);
    }
    
    DBG("Found ", symbolsTotal, " active symbols in Market Watch");
}

//+------------------------------------------------------------------+
//| Send heartbeat to GENESIS platform                               |
//+------------------------------------------------------------------+
bool SendHeartbeatToGenesis()
{
    // Prepare JSON data
    JsonToSend.Clear();
    JsonToSend["account_id"] = (StringLen(AccountName) > 0) ? AccountName : gAccountId;
    JsonToSend["terminal_id"] = IntegerToString(TerminalNumber);
    JsonToSend["connection_time"] = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS);
    
    // Send request
    string jsonString = JsonToSend.Serialize();
    string response = "";
    
    bool success = SendPostRequest(HEARTBEAT_URL, jsonString, response);
    
    if(success) {
        // Parse response
        JsonReceived.Clear();
        JsonReceived.Deserialize(response);
        
        if(JsonReceived["status"].ToStr() == "success") {
            DBG("Heartbeat sent successfully. Server time: ", JsonReceived["server_time"].ToStr());
            return true;
        }
        else {
            DBG("Error sending heartbeat: ", JsonReceived["message"].ToStr());
            return false;
        }
    }
    else {
        DBG("Failed to send heartbeat request");
        return false;
    }
}

//+------------------------------------------------------------------+
//| Get new signals from GENESIS platform                            |
//+------------------------------------------------------------------+
void GetNewSignalsFromGenesis()
{
// More detailed logging about API call
    DBG("Attempting to get signals from URL: ", SIGNALS_URL);

    // Prepare JSON data
    JsonToSend.Clear();
    JsonToSend["account_id"] = (StringLen(AccountName) > 0) ? AccountName : gAccountId;
    JsonToSend["last_signal_id"] = LastSignalId;
    
    // Create a JSON array with active symbols
    CJAVal symbolsArray;
    symbolsArray.Clear();
    for(int i = 0; i < ArraySize(ActiveSymbols); i++) {
        symbolsArray.Add(ActiveSymbols[i]);
    }
    JsonToSend["symbols"] = symbolsArray;
    
    // Send request
    string jsonString = JsonToSend.Serialize();
    string response = "";
    
    bool success = SendPostRequest(SIGNALS_URL, jsonString, response);
    
    if(success) {
        // Parse response
        JsonReceived.Clear();
        JsonReceived.Deserialize(response);
        
        if(JsonReceived["status"].ToStr() == "success") {
            // Process signals
            CJAVal signals = JsonReceived["signals"];
            int signalsCount = signals.Size();
            
            DBG("Received ", signalsCount, " new signals");
            
            for(int i = 0; i < signalsCount; i++) {

                CJAVal signal = signals[i];
                
                // Get signal data
                int signalId = (int)signal["id"].ToInt();
                string symbol = signal["asset"]["symbol"].ToStr();
                string direction = signal["action"].ToStr();
                double entry = signal["entry_price"].ToDbl();
                double stopLoss = signal["stop_loss"].ToDbl();
                double takeProfit = signal["take_profit"].ToDbl();
                double confidence = signal["confidence"].ToDbl();
                double lotSize = signal["position_size"].ToDbl() * LotMultiplier;
                bool force_execution = signal["force_execution"].ToBool();

                // Keep track of the highest signal ID
                if(signalId > LastSignalId) {
                    LastSignalId = signalId;
                }
                
                // Log detailed info about each signal AFTER extraction
                PrintFormat("Processing signal %d of %d:", i+1, signalsCount);
                int symbolDigits = GetSymbolDigits(symbol);
                DBG("  ID: ", signalId);
                DBG("  Symbol: ", symbol);
                DBG("  Action: ", direction);
                DBG("  Entry: ", DoubleToString(entry, symbolDigits));
                DBG("  Stop Loss: ", DoubleToString(stopLoss, symbolDigits));
                DBG("  Take Profit: ", DoubleToString(takeProfit, symbolDigits));
                // Check if we should trade this signal
                if(AutoTrade) {
                    ProcessTradeSignal(signalId, symbol, direction, entry, stopLoss, takeProfit, lotSize, force_execution);
                }
                else {
                    // Just print the signal
                    DBG("Signal: ID=", signalId, " Symbol=", symbol, " Direction=", direction, 
                          " Entry=", entry, " SL=", stopLoss, " TP=", takeProfit,
                          " Confidence=", confidence, " Lot=", lotSize);
                          
                    // Alert the user
                    string alertMessage = StringFormat("[GENESIS] %s Signal [%s] â€“ (Entry %.4f  SL %.4f  TP %.4f)", 
                                                      symbol, direction, entry, stopLoss, takeProfit);
                    Alert(alertMessage);
                }
            }
        }
        else {
            DBG("Error getting signals: ", JsonReceived["message"].ToStr());
        }
    }
    else {
        DBG("Failed to send signal request");
    }
}

//+------------------------------------------------------------------+
//| Process a trade signal and execute it                            |
//+------------------------------------------------------------------+
void ProcessTradeSignal(int signalId, string symbol, string direction, double entry, double stopLoss, double takeProfit, double lotSize, bool force_execution=false)
{
    bool isAnticipated = StringFind(direction, "ANTICIPATED") >= 0;
    // Detailed logging for signal processing
    int symbolDigits = GetSymbolDigits(symbol);
    DBG("  Entry: ", DoubleToString(entry, symbolDigits));
    DBG("  Stop Loss: ", DoubleToString(stopLoss, symbolDigits));
    DBG("  Take Profit: ", DoubleToString(takeProfit, symbolDigits));
    
    // Check if symbol is valid
    if(!SymbolSelect(symbol, true)) {
        DBG("Symbol ", symbol, " is not available. Signal cannot be processed.");
        if(SendReports) {
            SendTradeReport(signalId, symbol, direction, 0, 0, 0, 0, 0, "error", "Symbol not found");
        }
        return;
    }
    
    // Check if market is open for this symbol
    if(!IsMarketOpenForSymbol(symbol, force_execution)) {
        DBG("Market for ", symbol, " is closed. Signal will be executed when market opens.");
        if(SendReports) {
            SendTradeReport(signalId, symbol, direction, 0, 0, 0, 0, 0, "pending", "Market closed");
        }
        // Draw an arrow on chart for anticipated signals
        if(isAnticipated) {
            DrawSignalArrow(signalId, symbol, direction, entry);
        FireSignalAlert(direction, symbol, entry);
        }
        return;
    }
    
    // Determine order type
    ENUM_ORDER_TYPE orderType;
    
    if(StringFind(direction, "BUY") >= 0 || StringFind(direction, "LONG") >= 0) {
        orderType = ORDER_TYPE_BUY;
    }
    else if(StringFind(direction, "SELL") >= 0 || StringFind(direction, "SHORT") >= 0) {
        orderType = ORDER_TYPE_SELL;
    }
    else {
        DBG("Invalid direction: ", direction);
        if(SendReports) {
            SendTradeReport(signalId, symbol, direction, 0, 0, 0, 0, 0, "error", "Invalid direction");
        }
        return;
    }
    
    // Handle anticipated vs immediate signals differently
    if(isAnticipated) {
        // Draw an arrow on chart for anticipated signals
        DrawSignalArrow(signalId, symbol, direction, entry);
        
        // For anticipated signals, we set a limit or stop order at the specified entry price
        double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
        if(orderType == ORDER_TYPE_SELL)
            currentPrice = SymbolInfoDouble(symbol, SYMBOL_BID);
        
        ENUM_ORDER_TYPE pendingOrderType;
        
        if(orderType == ORDER_TYPE_BUY) {
            if(entry < currentPrice) {
                pendingOrderType = ORDER_TYPE_BUY_LIMIT; // Buy at a lower price than current
            }
            else {
                pendingOrderType = ORDER_TYPE_BUY_STOP; // Buy at a higher price than current
            }
        }
        else { // SELL
            if(entry > currentPrice) {
                pendingOrderType = ORDER_TYPE_SELL_LIMIT; // Sell at a higher price than current
            }
            else {
                pendingOrderType = ORDER_TYPE_SELL_STOP; // Sell at a lower price than current
            }
        }
        
        // Place the pending order
        DBG("Placing pending order: ", EnumToString(pendingOrderType), " for ", symbol, " at ", DoubleToString(entry, GetSymbolDigits(symbol)),
              " with SL: ", DoubleToString(stopLoss, GetSymbolDigits(symbol)), " TP: ", DoubleToString(takeProfit, GetSymbolDigits(symbol)),
              " Lot: ", DoubleToString(lotSize, 2));
              
        // Use Trade.OrderOpen() for pending orders
        bool success = Trade.OrderOpen(
            symbol,
            pendingOrderType,
            lotSize,
            0, // Current price, will be filled in by OrderOpen
            entry, // Price to trigger the order
            stopLoss,
            takeProfit,
            0, // No expiration
            0, // No expiration time
            "GENESIS Signal #" + IntegerToString(signalId)
        );
        
        if(success) {
            ulong ticket = Trade.ResultOrder();
            FireSignalAlert(direction, symbol, entry);

            DBG("Pending order placed successfully. Ticket: ", ticket);
            if(SendReports) {
                SendTradeReport(signalId, symbol, direction, ticket, lotSize, entry, stopLoss, takeProfit, "pending", "Pending order placed");
            }
        }
        else {
            int errorCode = GetLastError();
            string errorDesc = ErrorDescription(errorCode);
            DBG("Failed to place pending order. Error: ", errorCode, " - ", errorDesc);
            if(SendReports) {
                SendTradeReport(signalId, symbol, direction, 0, lotSize, entry, stopLoss, takeProfit, "error", "Error placing pending order: " + errorDesc);
            }
        }
    }
    else {
        // For immediate signals, place a market order
        DBG("Placing market order: ", EnumToString(orderType), " for ", symbol,
              " with SL: ", DoubleToString(stopLoss, GetSymbolDigits(symbol)), " TP: ", DoubleToString(takeProfit, GetSymbolDigits(symbol)),
              " Lot: ", DoubleToString(lotSize, 2));
              
        // Use Trade.PositionOpen() for market orders
        bool success = Trade.PositionOpen(
            symbol,
            orderType,
            lotSize,
            0, // Current price, will be filled in by PositionOpen
            stopLoss,
            takeProfit,
            "GENESIS Signal #" + IntegerToString(signalId)
        );
        
        if(success) {
            ulong ticket = Trade.ResultDeal();
            double price = Trade.ResultPrice();
            DrawSignalArrow(ticket, symbol, direction, price);
            DrawTradeLines(ticket, symbol, price, stopLoss, takeProfit);
            FireSignalAlert(direction, symbol, price);
            price = Trade.ResultPrice();
            DBG("Market order executed successfully. Ticket: ", ticket, " Price: ", DoubleToString(price, GetSymbolDigits(symbol)));
            if(SendReports) {
                SendTradeReport(signalId, symbol, direction, ticket, lotSize, price, stopLoss, takeProfit, "success", "Trade executed");
            }
        }
        else {
            int errorCode = GetLastError();
            string errorDesc = ErrorDescription(errorCode);
            DBG("Failed to execute market order. Error: ", errorCode, " - ", errorDesc);
            if(SendReports) {
                SendTradeReport(signalId, symbol, direction, 0, lotSize, 0, stopLoss, takeProfit, "error", "Error executing market order: " + errorDesc);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Draw a signal arrow on the chart                                 |
//+------------------------------------------------------------------+

void DrawSignalArrow(int signalId, string symbol, string direction, double entryPrice)
{
    // Create a unique object name and clean any existing one
    string objName = ArrowPrefix + IntegerToString(signalId);
    ObjectDelete(0, objName);

    // Decide arrow glyph & colour
    int   arrowCode;
    color arrowColor;
    bool isBuy = (StringFind(direction, "LONG") >= 0 || StringFind(direction, "BUY") >= 0);
    if(isBuy)
    {
        arrowCode  = 233;      // â–²  (Wingdings)
        arrowColor = clrLime;  // bright green
    }
    else
    {
        arrowCode  = 234;      // â–¼
        arrowColor = clrRed;   // red
    }

    // Offset: ~USD 2 for gold (point=0.01 on XAUUSD â†’ 200*point = $2)
    double point  = SymbolInfoDouble(symbol, SYMBOL_POINT);
    double offset = 400 * point;                 // make this big & easy to spot

    // Use current candle for placement; fall back to entryPrice if no data yet
    double candleHigh = iHigh(symbol, PERIOD_CURRENT, 0);
    double candleLow  = iLow (symbol, PERIOD_CURRENT, 0);
    if(candleHigh == 0 || candleLow == 0)
    {
        candleHigh = candleLow = entryPrice;
    }

    double arrowPrice = isBuy ? (candleLow  - offset)
                              : (candleHigh + offset);

    // Create and style the arrow
    if(ObjectCreate(0, objName, OBJ_ARROW, 0, TimeCurrent(), arrowPrice))
    {
        ObjectSetInteger(0, objName, OBJPROP_ARROWCODE, arrowCode);
        ObjectSetInteger(0, objName, OBJPROP_COLOR,     arrowColor);
        ObjectSetInteger(0, objName, OBJPROP_WIDTH,     2);        // BIG arrow
        ObjectSetInteger(0, objName, OBJPROP_SELECTABLE,false);

        string tip = "GENESIS Signal #" + IntegerToString(signalId) + "\n" + direction;
        ObjectSetString(0, objName, OBJPROP_TOOLTIP, tip);

        ChartRedraw(0);
        int symbolDigits = GetSymbolDigits(symbol);
        DBG("Drew signal arrow on chart: ", objName, " at ", DoubleToString(arrowPrice, symbolDigits));
    }
    else
    {
        DBG("Failed to create signal arrow on chart: ", objName, ", error: ", GetLastError());
    }
}

//+------------------------------------------------------------------+
//| Draw entry, SL and TP lines                                       |
//+------------------------------------------------------------------+
void DrawTradeLines(ulong ticket, string symbol, double entryPrice, double sl, double tp)
{
    string base = LinePrefix + IntegerToString(ticket);
    // Entry line (blue)
    string entryName = base + "_ENTRY";
    ObjectDelete(0, entryName);
    ObjectCreate(0, entryName, OBJ_HLINE, 0, 0, entryPrice);
    ObjectSetInteger(0, entryName, OBJPROP_COLOR, clrBlue);
    ObjectSetString(0, entryName, OBJPROP_TOOLTIP, "Entry " + DoubleToString(entryPrice, GetSymbolDigits(symbol)));
    // SL line (red)
    string slName = base + "_SL";
    ObjectDelete(0, slName);
    ObjectCreate(0, slName, OBJ_HLINE, 0, 0, sl);
    ObjectSetInteger(0, slName, OBJPROP_COLOR, clrRed);
    ObjectSetString(0, slName, OBJPROP_TOOLTIP, "Stop Loss " + DoubleToString(sl, GetSymbolDigits(symbol)));
    // TP line (green)
    string tpName = base + "_TP";
    ObjectDelete(0, tpName);
    ObjectCreate(0, tpName, OBJ_HLINE, 0, 0, tp);
    ObjectSetInteger(0, tpName, OBJPROP_COLOR, clrLime);
    ObjectSetString(0, tpName, OBJPROP_TOOLTIP, "Take Profit " + DoubleToString(tp, GetSymbolDigits(symbol)));
    ChartRedraw(0);
}

//+------------------------------------------------------------------+
//| Delete all signal arrows from the chart                          |
//+------------------------------------------------------------------+
void DeleteAllSignalArrows()
{
    int totalObjects = ObjectsTotal(0, 0, -1);
    
    for(int i = totalObjects - 1; i >= 0; i--) {
        string objName = ObjectName(0, i);
        if(StringFind(objName, ArrowPrefix) == 0) {
            ObjectDelete(0, objName);
        }
    }
    
    ChartRedraw(0);
    DBG("Deleted all signal arrows from chart");
}

//+------------------------------------------------------------------+
//| Send a trade report back to GENESIS                              |
//+------------------------------------------------------------------+
void SendTradeReport(int signalId, string symbol, string direction, ulong ticket, double lotSize,
                     double entryPrice, double stopLoss, double takeProfit, string status, string message)
{
    // Prepare JSON data
    JsonToSend.Clear();
    JsonToSend["signal_id"] = signalId;
    JsonToSend["account_id"] = (StringLen(AccountName) > 0) ? AccountName : gAccountId;
    JsonToSend["symbol"] = symbol;
    JsonToSend["action"] = direction;
    JsonToSend["ticket"] = IntegerToString(ticket);
    JsonToSend["lot_size"] = DoubleToString(lotSize, 2);
    JsonToSend["entry_price"] = DoubleToString(entryPrice, GetSymbolDigits(symbol));
    JsonToSend["stop_loss"] = DoubleToString(stopLoss, GetSymbolDigits(symbol));
    JsonToSend["take_profit"] = DoubleToString(takeProfit, GetSymbolDigits(symbol));
    JsonToSend["execution_time"] = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS);
    JsonToSend["status"] = status;
    JsonToSend["message"] = message;
    // ML context extras
    int spreadPts = SymbolInfoInteger(symbol,SYMBOL_SPREAD);
    double atr14     = iATR(symbol, PERIOD_H1, 14);
    double rsi14     = iRSI(symbol, PERIOD_H1, 14, PRICE_CLOSE);
    CJAVal ctx;
    ctx["spread_pts"] = IntegerToString((int)spreadPts);
    ctx["atr14"]      = DoubleToString(atr14,5);
    ctx["rsi14"]      = DoubleToString(rsi14,2);
    JsonToSend["ctx"] = ctx;
    
    // Send request
    string jsonString = JsonToSend.Serialize();
    string response = "";
    
    bool success = SendPostRequest(API_ENDPOINT + MT5_API_PATH + "/trade_report", jsonString, response);
    
    if(success) {
        // Parse response
        JsonReceived.Clear();
        JsonReceived.Deserialize(response);
        
        if(JsonReceived["status"].ToStr() == "success") {
            DBG("Trade report sent successfully for signal #", signalId);
        }
        else {
            DBG("Error sending trade report: ", JsonReceived["message"].ToStr());
        }
    }
    else {
        DBG("Failed to send trade report for signal #", signalId);
    }
}

//+------------------------------------------------------------------+
//| Send a POST request to the API                                   |
//+------------------------------------------------------------------+
bool SendPostRequest(string url,            // endpoint
                     string jsonText,       // JSON body as UTF-8 text
                     string &responseText)  // â† filled on success
{
   const int TIMEOUT_MS  = API_TIMEOUT;     // e.g. 10000
   const int MAX_RETRIES = 3;
   int       retryDelay  = 1000;            // 1 s â†’ 2 s â†’ 4 s

   //â€”â€” request headers â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   string reqHeaders = "Content-Type: application/json\r\n";
   if(StringLen(API_Key) > 0)
      reqHeaders += "Authorization: Bearer " + API_Key + "\r\n";

   //â€”â€” build payload as RAW BUFFER (char[]) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   char bodyBuf[];
   int  bytes = StringToCharArray(jsonText, bodyBuf, 0, WHOLE_ARRAY,
                                  CP_UTF8);
   if(bytes > 0) bytes--;                  // drop trailing '\0'

   char replyBuf[];
   string replyHdrs;

   //â€”â€” retry loop â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   for(int attempt = 1; attempt <= MAX_RETRIES; attempt++)
   {
      ResetLastError();                    // clear stale 5040 etc.  
      int http = WebRequest("POST",          // method
                      url,             // endpoint
                      reqHeaders,      // goes into the â€œcookieâ€ slot
                      TIMEOUT_MS,      // timeout (ms)
                      bodyBuf,         // payload
                      replyBuf,        // reply body
                      replyHdrs);      // reply headers

      int mqlErr = GetLastError();

      //â€”â€” success â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      if(http == 200)
      {
         responseText = CharArrayToString(replyBuf, 0,
                                          ArraySize(replyBuf));
         return true;
      }

      //â€”â€” transport failure (http == -1) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      if(http == -1 &&
         (mqlErr == 4060 || mqlErr == 4061 || mqlErr == 4062))
      {
         DBG("Transient WebRequest err ", mqlErr, " (",
             ErrorDescription(mqlErr), ") â€“ retry ", attempt,
             " in ", retryDelay/1000, " s");
         Sleep(retryDelay);
         retryDelay <<= 1;
         continue;
      }

      //â€”â€” server rejected or fatal transport â€”â€”â€”â€”â€”â€”â€”â€”
      string servReply = CharArrayToString(replyBuf, 0,
                                           ArraySize(replyBuf));
      DBG("WebRequest failed â€“ HTTP ", http,
          ", MQL ", mqlErr, " (", ErrorDescription(mqlErr),
          "), reply: ", servReply);
      break;
   }

   return false;                            // all retries failed
}

//+------------------------------------------------------------------+
//| Convert deinitialization reason code to text                     |
//+------------------------------------------------------------------+
string GetDeinitReasonText(int reasonCode)
{
    string text = "Unknown reason";
    
    switch(reasonCode) {
        case REASON_PROGRAM:     text = "Program called by ExpertRemove()"; break;
        case REASON_REMOVE:      text = "Program removed from chart"; break;
        case REASON_RECOMPILE:   text = "Program recompiled"; break;
        case REASON_CHARTCHANGE: text = "Symbol or timeframe changed"; break;
        case REASON_CHARTCLOSE:  text = "Chart closed"; break;
        case REASON_PARAMETERS:  text = "Parameters changed"; break;
        case REASON_ACCOUNT:     text = "Another account activated"; break;
        case REASON_TEMPLATE:    text = "New template applied"; break;
        case REASON_INITFAILED:  text = "OnInit() handler returned non-zero value"; break;
        case REASON_CLOSE:       text = "Terminal closed"; break;
    }
    
    return text;
}

//+------------------------------------------------------------------+
//| Check if market is open for a specific symbol                    |
//+------------------------------------------------------------------+
bool IsMarketOpenForSymbol(string symbol, bool force_execution=false)
{
    // If force execution is enabled, return true regardless
    if(force_execution) {
        DBG("Force execution enabled for ", symbol, ", bypassing market open check");
        return true;
    }
    
    // Get trading session info
    datetime now = TimeCurrent();
    
    // Check if trading is allowed for the symbol
    long tradeMode;
    if(SymbolInfoInteger(symbol, SYMBOL_TRADE_MODE, tradeMode)) {
        if(tradeMode == SYMBOL_TRADE_MODE_DISABLED) {
            DBG("Trading is disabled for ", symbol);
            return false;
        }
    }
    
    // Check if outside of defined trading sessions
    datetime sess_from, sess_to;
    if(SymbolInfoSessionQuote(symbol, MONDAY, 0, sess_from, sess_to)) {
        MqlDateTime timeStruct;
        TimeToStruct(now, timeStruct);
        
        int day_of_week = timeStruct.day_of_week;
        datetime from, to;
        
        // Check if current time is within a trading session
        if(SymbolInfoSessionQuote(symbol, (ENUM_DAY_OF_WEEK)day_of_week, 0, from, to)) {
            if(now >= from && now <= to) {
                return true;
            }
            else {
                // Check additional sessions for the day
                for(int session = 1; session < 10; session++) {
                    if(SymbolInfoSessionQuote(symbol, (ENUM_DAY_OF_WEEK)day_of_week, session, from, to)) {
                        if(now >= from && now <= to) {
                            return true;
                        }
                    }
                    else {
                        break; // No more sessions
                    }
                }
                DBG("Market for ", symbol, " is closed now");
                return false;
            }
        }
    }
    
    // Default to true if no sessions defined or if checks pass
    return true;
}

//+------------------------------------------------------------------+

//| Send account status to GENESIS                                     |

//+------------------------------------------------------------------+

void SendAccountStatus()
{

    JsonToSend.Clear();

    JsonToSend["account_id"] = (StringLen(AccountName) > 0) ? AccountName : gAccountId;

    JsonToSend["balance"] = AccountInfoDouble(ACCOUNT_BALANCE);

    JsonToSend["equity"] = AccountInfoDouble(ACCOUNT_EQUITY);

    JsonToSend["margin"] = AccountInfoDouble(ACCOUNT_MARGIN);

    JsonToSend["free_margin"] = AccountInfoDouble(ACCOUNT_FREEMARGIN);

    string jsonString = JsonToSend.Serialize();

    string response = "";

    SendPostRequest(ACCOUNT_STATUS_URL, jsonString, response);

}

//+------------------------------------------------------------------+

//| Send open trades to GENESIS                                       |

//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| Send open trades and history to GENESIS                          |
//+------------------------------------------------------------------+
// Define a simple string array at a global level to track sent trades
string g_sentTradeIds[100];  // Fixed size array
int g_sentTradeCount = 0;
// Function to check if a trade was already sent
bool IsTradeAlreadySent(string tradeId)
{
   for(int i=0; i<g_sentTradeCount; i++)
   {
      if(g_sentTradeIds[i] == tradeId)
         return true;
   }
   return false;
}
// Function to mark a trade as sent
void MarkTradeAsSent(string tradeId)
{
   if(g_sentTradeCount < 100)  // Avoid buffer overflow
   {
      g_sentTradeIds[g_sentTradeCount] = tradeId;
      g_sentTradeCount++;
   }
}
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Function : SendTradeUpdates  (batched, â‰¤20 trades per WebRequest)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
void SendTradeUpdates()
{
   DBG("======= STARTING TRADE UPDATES =======");

   //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1. build the full 'trades' object â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   int openPosTotal = PositionsTotal();
   DBG("Found " + IntegerToString(openPosTotal) + " open positions");

   JsonToSend.Clear();
   JsonToSend["account_id"] = (StringLen(AccountName) > 0) ? AccountName : gAccountId;

   CJAVal trades;                trades.Clear();
   string tradeKeys[];           // keep ticket / position IDs in order
   int    keyCount = 0;
   bool   hasData  = false;

   //â€•â€•â€• OPEN positions â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
   for(int i = 0; i < openPosTotal; i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket)) continue;

      string   symbol        = PositionGetString(POSITION_SYMBOL);
      double   open_price    = PositionGetDouble(POSITION_PRICE_OPEN);
      double   current_price = PositionGetDouble(POSITION_PRICE_CURRENT);
      double   profit        = PositionGetDouble(POSITION_PROFIT);
      datetime open_time     = (datetime)PositionGetInteger(POSITION_TIME);

      CJAVal trade;
      trade["symbol"]      = symbol;
      trade["lot"]         = DoubleToString(PositionGetDouble(POSITION_VOLUME),2);
      trade["type"]        = (PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY) ? "BUY" : "SELL";
      trade["open_price"]  = DoubleToString(open_price,  GetSymbolDigits(symbol));
      trade["sl"]          = DoubleToString(PositionGetDouble(POSITION_SL), GetSymbolDigits(symbol));
      trade["tp"]          = DoubleToString(PositionGetDouble(POSITION_TP), GetSymbolDigits(symbol));
      trade["profit"]      = DoubleToString(profit,2);
      trade["status"]      = "OPEN";

      if(open_time>0)
         trade["opened_at"] = TimeToString(open_time, TIME_DATE|TIME_SECONDS);

      string key = IntegerToString(ticket);
      trades[key] = trade;

      ArrayResize(tradeKeys, ++keyCount);
      tradeKeys[keyCount-1] = key;
      hasData = true;
   }

   //â€•â€•â€• CLOSED trades (last 3 days) â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
   datetime endTime   = TimeCurrent();
   datetime startTime = endTime - 3*24*60*60;          // 3-day window

   if(HistorySelect(startTime, endTime))
   {
      int dealsTotal = HistoryDealsTotal();

      for(int i = 0; i < dealsTotal; i++)
      {
         ulong dealId = HistoryDealGetTicket(i);
         if(dealId == 0) continue;

         if(HistoryDealGetInteger(dealId, DEAL_ENTRY) != DEAL_ENTRY_OUT)
            continue;                                   // we want OUT deals only

         ENUM_DEAL_TYPE dealType = (ENUM_DEAL_TYPE)HistoryDealGetInteger(dealId, DEAL_TYPE);
         if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)
            continue;

         string   symbol    = HistoryDealGetString(dealId, DEAL_SYMBOL);
         double   volume    = HistoryDealGetDouble(dealId, DEAL_VOLUME);
         double   exitPrice = HistoryDealGetDouble(dealId, DEAL_PRICE);
         double   profit    = HistoryDealGetDouble(dealId, DEAL_PROFIT);
         datetime closeTime = (datetime)HistoryDealGetInteger(dealId, DEAL_TIME);
         ulong    posId     = HistoryDealGetInteger(dealId, DEAL_POSITION_ID);

         // find matching IN deal to get entry price & side
         double   entryPrice = 0;
         datetime openTime   = 0;
         string   side       = "BUY";

         for(int j = 0; j < dealsTotal; j++)
         {
            ulong inId = HistoryDealGetTicket(j);
            if(inId == 0) continue;

            if(HistoryDealGetInteger(inId, DEAL_POSITION_ID) == posId &&
               HistoryDealGetInteger(inId, DEAL_ENTRY) == DEAL_ENTRY_IN)
            {
               entryPrice = HistoryDealGetDouble(inId, DEAL_PRICE);
               openTime   = (datetime)HistoryDealGetInteger(inId, DEAL_TIME);
               ENUM_DEAL_TYPE inType = (ENUM_DEAL_TYPE)HistoryDealGetInteger(inId, DEAL_TYPE);
               side = (inType == DEAL_TYPE_BUY) ? "BUY" : "SELL";
               break;
            }
         }

         CJAVal trade;
         trade["symbol"]      = symbol;
         trade["lot"]         = DoubleToString(volume,2);
         trade["type"]        = side;
         trade["open_price"]  = DoubleToString(entryPrice, GetSymbolDigits(symbol));
         trade["exit_price"]  = DoubleToString(exitPrice, GetSymbolDigits(symbol));
         trade["profit"]      = DoubleToString(profit,2);
         trade["status"]      = "CLOSED";
         trade["closed_at"]   = TimeToString(closeTime, TIME_DATE|TIME_SECONDS);
         if(openTime>0)
            trade["opened_at"] = TimeToString(openTime, TIME_DATE|TIME_SECONDS);

         string key = IntegerToString(posId);
         trades[key] = trade;

         ArrayResize(tradeKeys, ++keyCount);
         tradeKeys[keyCount-1] = key;
         hasData = true;
      }
   }

   //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. send in â‰¤20-trade chunks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   int sent = 0;

   for(int offset = 0; offset < keyCount; offset += MAX_TRADES_PER_UPDATE)
   {
      int upto = (offset + MAX_TRADES_PER_UPDATE > keyCount)
                 ? keyCount
                 : offset + MAX_TRADES_PER_UPDATE;

      CJAVal payload;          payload.Clear();
      payload["account_id"] = gAccountId;

      CJAVal slice;            slice.Clear();

      for(int k = offset; k < upto; k++)
      {
         string tKey = tradeKeys[k];
         slice[tKey] = trades[tKey];
      }
      payload["trades"] = slice;

      string body     = payload.Serialize();
      string response = "";

      bool success = SendPostRequest(TRADE_UPDATE_URL, body, response);

      if(success)
      {
         DBG(StringFormat("âœ“ Sent trade chunk %dâ€“%d  (%s)",
                          offset+1, upto, response));
         sent += (upto - offset);
         Sleep(300);                         // avoids server flood-limit
      }
      else
      {
         DBG(StringFormat("Chunk %dâ€“%d FAILED â€“ retry next cycle",
                          offset+1, upto));
         break;                              // leave remaining chunks for next timer run
      }
   }

   //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3. wrap-up logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if(sent == keyCount)
      DBG("All trade records delivered (" + IntegerToString(sent) + ")");
   else
      DBG("Delivered " + IntegerToString(sent) +
          " of " + IntegerToString(keyCount) + " records this cycle");

   if(!hasData)
      DBG("Snapshot contained no open or closed trades â€“ server will mark account flat");

   DBG("======= COMPLETED TRADE UPDATES =======");
}



//+------------------------------------------------------------------+
//| Pop-up alert helper                                              |
//+------------------------------------------------------------------+
void FireSignalAlert(string direction, string symbol, double price)
{
    if(!ShowAlerts) return;
    int symbolDigits = GetSymbolDigits(symbol);
    string msg = StringFormat("[GENESIS] %s Signal [%s] â€“ (%s)", direction, symbol, DoubleToString(price, symbolDigits));
    Alert(msg);
}